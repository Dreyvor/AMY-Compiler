package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
        // Generate code for the "main" function, which contains the module expression
        optExpr.toList.map { expr =>
          val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
          cgFunction(mainFd, name, true)
        }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain) { lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
          // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        // Literals
        case IntLiteral(v) => Const(v)
        case BooleanLiteral(v) => if (v) Const(1) else Const(0)
        case StringLiteral(s) => mkString(s)
        case UnitLiteral() => Const(0)

        // Variable
        case Variable(name) => GetLocal(locals(name))

        // Binary operators
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s

        // Evaluates lhs, if return is 0 ==> return 0, else return the evaluated rhs' value
        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")
        case Not(lhs) => cgExpr(lhs) <:> If_i32 <:> Const(0) <:> Else <:> Const(1) <:> End
        case Neg(lhs) => Const(0) <:> cgExpr(lhs) <:> Sub

        // Harder translations
        case AmyCall(qname, args) => // Remember that it can be a function or a constructor !
          val fct = table.getFunction(qname)
          if (fct.isDefined) {
            //it's a function call ==> put args on the stack then call the fct
            args.map(cgExpr(_)) <:> Call(fullName(fct.get.owner, qname))
          } else {
            //it's a constructor
            val idxConstr = table.getConstructor(qname).get.index
            val idxB = lh.getFreshLocal()

            //Now exec algorithm from slides
            //Save the old memory boundary b
            GetLocal(memoryBoundary) <:> SetLocal(idxB) <:>
              // Increment memory boundary by the size of the allocated ADT
              GetLocal(memoryBoundary) <:> adtField(args.size) <:> SetLocal(memoryBoundary) <:>
              // Store the constructor index to address b
              GetLocal(idxB) <:> Const(idxConstr) <:> Store <:>
              // For each field of the constructor, generate code for it and store it in memory in the correct offset from b
              args.zipWithIndex.map { case (arg, idx) => GetLocal(idxB) <:> adtField(idx) <:> cgExpr(arg) <:> Store } <:>
              // Push b to the stack (base address of the ADT)
              GetLocal(idxB)
          }

        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)

        case Let(df, value, body) => //We have to add something to locals
          val idx: Int = lh.getFreshLocal()
          val newLocals: Map[Identifier, Int] = locals + (df.name -> idx)
          cgExpr(value) <:> SetLocal(idx) <:> cgExpr(body)(newLocals, lh)

        case Ite(cond, thenn, elze) => cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End

        case Match(scrut, cases) =>
          val scrutVal = lh.getFreshLocal()

          def resolveCases(cases: List[MatchCase]): Code = {
            cases match {
              case Nil => mkString("ERROR: No case matches") <:> Call("Std_printString") <:> Unreachable
              case head :: tl =>
                val (caseCode, newLocals) = matchAndBind(head.pat)
                GetLocal(scrutVal) <:> caseCode <:> If_i32 <:> cgExpr(head.expr)(locals ++ newLocals, lh) <:> Else <:> resolveCases(tl) <:> End
            }
          }

          def matchAndBind(p: Pattern)(implicit locals: Map[Identifier, Int]): (Code, Map[Identifier, Int]) = {
            p match {
              case WildcardPattern() =>
                (Drop <:> Const(1), Map.empty)

              case LiteralPattern(lit) =>
                (cgExpr(lit) <:> Eq, Map.empty)

              case IdPattern(name) =>
                val idxName = lh.getFreshLocal()
                (SetLocal(idxName) <:> Const(1), Map(name -> idxName))

              case CaseClassPattern(constr, args) =>
                val constrLocal = lh.getFreshLocal()
                val idxConstr = table.getConstructor(constr).get.index
                var newLocalsAcc: Map[Identifier, Int] = Map.empty
                /*val fillArgs: Code = if (args.nonEmpty) args.zipWithIndex.map {
                  case (arg, idx) =>
                    val (code, newLocals) = matchAndBind(arg)
                    newLocalsAcc = newLocalsAcc ++ newLocals
                    GetLocal(constrLocal) <:> adtField(idx) <:> Load <:> code
                } else Const(1)
                */

                (SetLocal(constrLocal) <:> GetLocal(constrLocal) <:> Load <:> Const(idxConstr) <:> Eq <:> //If_i32 <:>
                  args.zipWithIndex.map {
                    case (arg, idx) =>
                      val (code, newLocals) = matchAndBind(arg)
                      newLocalsAcc = newLocalsAcc ++ newLocals
                      GetLocal(constrLocal) <:> adtField(idx) <:> Load <:> code
                  } <:> List.fill(args.size)(And) /*<:> Else <:> Const(0) <:> End*/, newLocalsAcc)
            }
          }

          cgExpr(scrut) <:> SetLocal(scrutVal) <:> resolveCases(cases)

        case Error(msg) => cgExpr(msg) <:> Call("Std_printString") <:> Unreachable //print error then fails the program
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
