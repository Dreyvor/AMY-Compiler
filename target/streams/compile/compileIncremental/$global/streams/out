[0m[[0m[0mdebug[0m] [0m[0mInvalidating /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/lib/amyc-frontend-1.6.jar: could not find class amyc.ast.TreeModule$Error on the classpath.[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set(/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/interpreter/Interpreter.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/parsing/Tokens.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Position.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Pipeline.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/UniqueCounter.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Env.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Context.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Document.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Reporter.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/AmycFatalError.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/parsing/Lexer.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set(/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/Main.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set(/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/lib/amyc-frontend-1.6.jar)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(amyc.interpreter.Interpreter.CaseClassValue, amyc.interpreter.Interpreter.Value, amyc.Main, amyc.interpreter.Interpreter.BooleanValue, amyc.interpreter.Interpreter, amyc.interpreter.Interpreter.IntValue, amyc.interpreter.Interpreter.StringValue, amyc.interpreter.Interpreter.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set(/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/Main.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/interpreter/Interpreter.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set(amyc.interpreter.Interpreter.CaseClassValue, amyc.interpreter.Interpreter.Value, amyc.Main, amyc.interpreter.Interpreter.BooleanValue, amyc.interpreter.Interpreter, amyc.interpreter.Interpreter.IntValue, amyc.interpreter.Interpreter.StringValue, amyc.interpreter.Interpreter.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/parsing/Tokens.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Position.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Pipeline.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/UniqueCounter.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/Main.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Env.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Context.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Document.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/Reporter.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/interpreter/Interpreter.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/utils/AmycFatalError.scala, /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/src/amyc/parsing/Lexer.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mRecompiling all 11 sources: invalidated sources (12) exceeded 50.0% of all sources[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 11 Scala sources to /media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/target/scala-2.12/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.2.5:compile for Scala 2.12.3[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.2.5:compile for Scala 2.12.3[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 3914e62b for Scala compiler version 2.12.3[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-feature[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes:/home/brad/.ivy2/cache/org.scala-lang/scala-library/jars/scala-library-2.12.3.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/target/scala-2.12/classes:/media/brad/HDD_1TB_intern/EPFL/SYSCOM/BA7/Computer_language_processing/AMY-Compiler/lib/scallion_2.12-0.3.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 2.74294094 s[0m
[0m[[0m[0minfo[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.OperatorKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.EOFKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.NoKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.DelimiterKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.LiteralKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.IdentifierKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.KeywordKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.TokenKinds.PrimTypeKind by amyc.parsing.TokenKind[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.OperatorKind, amyc.parsing.TokenKinds.EOFKind, amyc.parsing.TokenKinds.NoKind, amyc.parsing.TokenKinds.DelimiterKind, amyc.parsing.TokenKinds.LiteralKind, amyc.parsing.TokenKinds.IdentifierKind, amyc.parsing.TokenKind, amyc.parsing.TokenKinds.KeywordKind, amyc.parsing.TokenKinds.PrimTypeKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKind,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(TokenKind,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(of,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(amyc;parsing;TokenKind;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 9 classes due to The amyc.parsing.TokenKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(TokenKind,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(of,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(amyc;parsing;TokenKind;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.OperatorKind, amyc.parsing.TokenKinds.EOFKind, amyc.parsing.TokenKinds.NoKind, amyc.parsing.TokenKinds.DelimiterKind, amyc.parsing.TokenKinds.LiteralKind, amyc.parsing.TokenKinds.IdentifierKind, amyc.parsing.TokenKind, amyc.parsing.TokenKinds.KeywordKind, amyc.parsing.TokenKinds.PrimTypeKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter.CaseClassValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter.CaseClassValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter.CaseClassValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter.CaseClassValue,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(constructor,[Default]), UsedName(hashCode,[Default]), UsedName(CaseClassValue,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$2,[Default]), UsedName(args,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(amyc;interpreter;Interpreter;CaseClassValue;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(tupled,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(curried,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter.CaseClassValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(constructor,[Default]), UsedName(hashCode,[Default]), UsedName(CaseClassValue,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$2,[Default]), UsedName(args,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(amyc;interpreter;Interpreter;CaseClassValue;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(tupled,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(curried,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter.CaseClassValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.SpaceToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.SpaceToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.SpaceToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.SpaceToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(SpaceToken,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(amyc;parsing;Tokens;SpaceToken;init;,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.SpaceToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(SpaceToken,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(amyc;parsing;Tokens;SpaceToken;init;,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.SpaceToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Stacked...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Stacked)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Stacked)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Stacked,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(apply$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName(Stacked,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(<init>$default$2,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(emptyLines,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(amyc;utils;Stacked;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(docs,[Default]), UsedName(productArity,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.utils.Stacked has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(apply$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName(Stacked,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(<init>$default$2,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(emptyLines,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(amyc;utils;Stacked;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(docs,[Default]), UsedName(productArity,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Stacked)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter.StringValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter.StringValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter.StringValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter.StringValue,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(s,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(StringValue,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(amyc;interpreter;Interpreter;StringValue;init;,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter.StringValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(s,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(StringValue,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(amyc;interpreter;Interpreter;StringValue;init;,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter.StringValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.StringLitToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.StringLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.StringLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.StringLitToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(amyc;parsing;Tokens;StringLitToken;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(StringLitToken,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.StringLitToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(amyc;parsing;Tokens;StringLitToken;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(StringLitToken,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.StringLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Env.Linux...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Env.Linux)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Env.Linux)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Env.Linux,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(Linux,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.utils.Env.Linux has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(Linux,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Env.Linux)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Position...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Position)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.NoPosition by amyc.utils.Position[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.SourcePosition by amyc.utils.Position[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Position, amyc.utils.NoPosition, amyc.utils.SourcePosition)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Token: Set(UsedName(withoutFile,[Default]), UsedName(Position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Reporter: Set(UsedName(fromFile,[Default]), UsedName(file,[Default]), UsedName(col,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Position,[Default]), UsedName(line,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(fromFile,[Default]), UsedName(file,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(isInstanceOf,[Default]), UsedName(Position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Reporter: Set(UsedName(fromFile,[Default]), UsedName(file,[Default]), UsedName(col,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Position,[Default]), UsedName(line,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(fromFile,[Default]), UsedName(file,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Position,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(fromFile,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(withoutFile,[Default]), UsedName(notify,[Default]), UsedName(col,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(Position,[Default]), UsedName(clone,[Default]), UsedName(line,[Default]), UsedName(amyc;utils;Position;init;,[Default]))) invalidates 7 classes due to The amyc.utils.Position has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(fromFile,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(withoutFile,[Default]), UsedName(notify,[Default]), UsedName(col,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(Position,[Default]), UsedName(clone,[Default]), UsedName(line,[Default]), UsedName(amyc;utils;Position;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Position, amyc.utils.NoPosition, amyc.utils.SourcePosition)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Token, amyc.utils.Reporter, amyc.parsing.Lexer, amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Document...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Document)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Unindented by amyc.utils.Document[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Lined by amyc.utils.Document[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Raw by amyc.utils.Document[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Stacked by amyc.utils.Document[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Indented by amyc.utils.Document[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Unindented, amyc.utils.Document, amyc.utils.Lined, amyc.utils.Raw, amyc.utils.Stacked, amyc.utils.Indented)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Document,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(amyc;utils;Document;init;,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(Document,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 6 classes due to The amyc.utils.Document has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(amyc;utils;Document;init;,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(Document,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Unindented, amyc.utils.Document, amyc.utils.Lined, amyc.utils.Raw, amyc.utils.Stacked, amyc.utils.Indented)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Lexer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following member ref dependencies of amyc.parsing.Lexer are invalidated:[0m
[0m[[0m[0mdebug[0m] [0m[0m	amyc.Main[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Lexer,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(DFA,[Default]), UsedName(Predicated,[Default]), UsedName(many,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(Lexer,[Default]), UsedName(notify,[Default]), UsedName(ProducerDecorator,[Implicit]), UsedName(synchronized,[Default]), UsedName(Leaf,[Default]), UsedName(wait,[Default]), UsedName(Epsilon,[Default]), UsedName(Valued,[Default]), UsedName(oneOf,[Default]), UsedName(elem,[Default]), UsedName(many1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Producer,[Default]), UsedName(Guarded,[Default]), UsedName(Condition,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(Transition,[Default]), UsedName(ne,[Default]), UsedName(DecisionTree,[Default]), UsedName(equals,[Default]), UsedName(RegExp,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(NFA,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(Branch,[Default]), UsedName(opt,[Default]), UsedName(word,[Default]), UsedName(lexer,[Default]), UsedName(any,[Default]))) invalidates 2 classes due to The amyc.parsing.Lexer has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ProducerDecorator,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.KeywordToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.KeywordToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.KeywordToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(KeywordToken,[Default]), UsedName(apply,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.KeywordToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(amyc;parsing;Tokens;KeywordToken;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(KeywordToken,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 2 classes due to The amyc.parsing.Tokens.KeywordToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(amyc;parsing;Tokens;KeywordToken;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(KeywordToken,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.KeywordToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Noop...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Noop)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Noop)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Noop,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(amyc;utils;Noop;init;,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(Noop,[Default]))) invalidates 1 classes due to The amyc.utils.Noop has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(amyc;utils;Noop;init;,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(Noop,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Noop)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Indented...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Indented)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Indented)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Indented,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(amyc;utils;Indented;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(Indented,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.utils.Indented has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(amyc;utils;Indented;init;,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(Indented,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Indented)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(CaseClassValue,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(IntValue,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(Interpreter,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(BooleanValue,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(StringValue,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(UnitValue,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(Value,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(CaseClassValue,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(IntValue,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(Interpreter,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(BooleanValue,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(StringValue,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(UnitValue,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(Value,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.DisplayTokens...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.DisplayTokens)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.DisplayTokens)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(run,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(DisplayTokens,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.DisplayTokens,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(DisplayTokens,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 2 classes due to The amyc.parsing.DisplayTokens has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(DisplayTokens,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.DisplayTokens)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Lined...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Lined)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Lined)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Lined,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName(Lined,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(separator,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(docs,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(amyc;utils;Lined;init;,[Default]))) invalidates 1 classes due to The amyc.utils.Lined has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName(Lined,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(separator,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(docs,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(amyc;utils;Lined;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Lined)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Env.Mac...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Env.Mac)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Env.Mac)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Env.Mac,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Mac,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.utils.Env.Mac has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Mac,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Env.Mac)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Positioned...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Positioned)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Token by amyc.utils.Positioned[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.ErrorToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.CommentToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.PrimTypeToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.IdentifierToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.SpaceToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.StringLitToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.OperatorToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.EOFToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.KeywordToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.BoolLitToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.DelimiterToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.IntLitToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.ErrorToken, amyc.parsing.Tokens.CommentToken, amyc.parsing.Tokens.PrimTypeToken, amyc.parsing.Tokens.IdentifierToken, amyc.parsing.Tokens.SpaceToken, amyc.parsing.Tokens.StringLitToken, amyc.parsing.Tokens.OperatorToken, amyc.parsing.Token, amyc.parsing.Tokens.EOFToken, amyc.parsing.Tokens.KeywordToken, amyc.utils.Positioned, amyc.parsing.Tokens.BoolLitToken, amyc.parsing.Tokens.DelimiterToken, amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mNone of the modified names appears in source file of amyc.parsing.DisplayTokens. This dependency is not being considered for invalidation.[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(isInstanceOf,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Token: Set(UsedName(Positioned,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Reporter: Set(UsedName(Positioned,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Positioned,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(Positioned,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(position,[Default]))) invalidates 17 classes due to The amyc.utils.Positioned has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(Positioned,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.ErrorToken, amyc.parsing.Tokens.CommentToken, amyc.parsing.Tokens.PrimTypeToken, amyc.parsing.Tokens.IdentifierToken, amyc.parsing.Tokens.SpaceToken, amyc.parsing.Tokens.StringLitToken, amyc.parsing.Tokens.OperatorToken, amyc.parsing.Token, amyc.parsing.Tokens.EOFToken, amyc.parsing.Tokens.KeywordToken, amyc.utils.Positioned, amyc.parsing.Tokens.BoolLitToken, amyc.parsing.Tokens.DelimiterToken, amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.utils.Reporter, amyc.parsing.Token, amyc.Main, amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(NoKind,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(LiteralKind,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(IdentifierKind,[Default]), UsedName(TokenKinds,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(DelimiterKind,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(PrimTypeKind,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(KeywordKind,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(EOFKind,[Default]), UsedName(OperatorKind,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(NoKind,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(LiteralKind,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(IdentifierKind,[Default]), UsedName(TokenKinds,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(DelimiterKind,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(PrimTypeKind,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(KeywordKind,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(EOFKind,[Default]), UsedName(OperatorKind,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.PrimTypeToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.PrimTypeToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.PrimTypeToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.PrimTypeToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(amyc;parsing;Tokens;PrimTypeToken;init;,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(PrimTypeToken,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.PrimTypeToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(amyc;parsing;Tokens;PrimTypeToken;init;,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(PrimTypeToken,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.PrimTypeToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.SourcePosition...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.SourcePosition)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.SourcePosition)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(file,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(SourcePosition,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.SourcePosition,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(copy$default$3,[Default]), UsedName(amyc;utils;SourcePosition;init;,[Default]), UsedName(hashCode,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(withoutFile,[Default]), UsedName(notify,[Default]), UsedName(col,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(SourcePosition,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(line,[Default]))) invalidates 2 classes due to The amyc.utils.SourcePosition has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(copy$default$3,[Default]), UsedName(amyc;utils;SourcePosition;init;,[Default]), UsedName(hashCode,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(withoutFile,[Default]), UsedName(notify,[Default]), UsedName(col,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(SourcePosition,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(line,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.SourcePosition)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.IdentifierKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.IdentifierKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.IdentifierKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.IdentifierKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(IdentifierKind,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.IdentifierKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(IdentifierKind,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.IdentifierKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Reporter...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Reporter)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Reporter)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Context: Set(UsedName(toString,[Default]), UsedName(Reporter,[Default]), UsedName(asInstanceOf,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(eq,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(fatal$default$2,[Default]), UsedName(Reporter,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(error,[Default]), UsedName(fatal,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Pipeline: Set(UsedName(Reporter,[Default]), UsedName(terminateIfErrors,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(fatal$default$2,[Default]), UsedName(Reporter,[Default]), UsedName(terminateIfErrors,[Default]), UsedName(isInstanceOf,[Default]), UsedName(amyc;utils;Reporter;init;,[Default]), UsedName(fatal,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Reporter,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(error$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(fatal$default$2,[Default]), UsedName(Reporter,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(warning$default$2,[Default]), UsedName(asInstanceOf,[Default]), UsedName(info,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName(terminateIfErrors,[Default]), UsedName($isInstanceOf,[Default]), UsedName(info$default$2,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(error,[Default]), UsedName(eq,[Default]), UsedName(amyc;utils;Reporter;init;,[Default]), UsedName(clone,[Default]), UsedName(warning,[Default]), UsedName(fatal,[Default]))) invalidates 5 classes due to The amyc.utils.Reporter has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(error$default$2,[Default]), UsedName(hashCode,[Default]), UsedName(fatal$default$2,[Default]), UsedName(Reporter,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(warning$default$2,[Default]), UsedName(asInstanceOf,[Default]), UsedName(info,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName(terminateIfErrors,[Default]), UsedName($isInstanceOf,[Default]), UsedName(info$default$2,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(error,[Default]), UsedName(eq,[Default]), UsedName(amyc;utils;Reporter;init;,[Default]), UsedName(clone,[Default]), UsedName(warning,[Default]), UsedName(fatal,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Reporter)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.utils.Context, amyc.parsing.Lexer, amyc.utils.Pipeline, amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.IdentifierToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.IdentifierToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.IdentifierToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.IdentifierToken,ModifiedNames(changes = UsedName(name,[Default]), UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(IdentifierToken,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(amyc;parsing;Tokens;IdentifierToken;init;,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.IdentifierToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(name,[Default]), UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(IdentifierToken,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(amyc;parsing;Tokens;IdentifierToken;init;,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.IdentifierToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(CommentToken,[Default]), UsedName(EOFToken,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Tokens,[Default]), UsedName(ErrorToken,[Default]), UsedName(KeywordToken,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens,ModifiedNames(changes = UsedName(DelimiterToken,[Default]), UsedName(toString,[Default]), UsedName(IntLitToken,[Default]), UsedName(CommentToken,[Default]), UsedName(hashCode,[Default]), UsedName(EOFToken,[Default]), UsedName(IdentifierToken,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(SpaceToken,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(PrimTypeToken,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Tokens,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(OperatorToken,[Default]), UsedName(StringLitToken,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(ErrorToken,[Default]), UsedName(KeywordToken,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(BoolLitToken,[Default]))) invalidates 2 classes due to The amyc.parsing.Tokens has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(DelimiterToken,[Default]), UsedName(toString,[Default]), UsedName(IntLitToken,[Default]), UsedName(CommentToken,[Default]), UsedName(hashCode,[Default]), UsedName(EOFToken,[Default]), UsedName(IdentifierToken,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(SpaceToken,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(PrimTypeToken,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Tokens,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(OperatorToken,[Default]), UsedName(StringLitToken,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(ErrorToken,[Default]), UsedName(KeywordToken,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(BoolLitToken,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.NoPosition...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.NoPosition)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.NoPosition)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Reporter: Set(UsedName(file,[Default]), UsedName(col,[Default]), UsedName(NoPosition,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(line,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.NoPosition,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(withoutFile,[Default]), UsedName(notify,[Default]), UsedName(col,[Default]), UsedName(synchronized,[Default]), UsedName(NoPosition,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(line,[Default]))) invalidates 2 classes due to The amyc.utils.NoPosition has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(withoutFile,[Default]), UsedName(notify,[Default]), UsedName(col,[Default]), UsedName(synchronized,[Default]), UsedName(NoPosition,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isDefined,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(line,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.NoPosition)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.utils.Reporter)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.LiteralKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.LiteralKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.LiteralKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.LiteralKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(LiteralKind,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.LiteralKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(LiteralKind,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.LiteralKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter.IntValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter.IntValue,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(amyc;interpreter;Interpreter;IntValue;init;,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$1,[Default]), UsedName(IntValue,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(i,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter.IntValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(amyc;interpreter;Interpreter;IntValue;init;,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$1,[Default]), UsedName(IntValue,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(i,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.OperatorKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.OperatorKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.OperatorKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.OperatorKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(amyc;parsing;TokenKinds;OperatorKind;init;,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(OperatorKind,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.OperatorKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(amyc;parsing;TokenKinds;OperatorKind;init;,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(OperatorKind,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.OperatorKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.EOFToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.EOFToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.EOFToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(EOFToken,[Default]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.EOFToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(EOFToken,[Default]), UsedName(amyc;parsing;Tokens;EOFToken;init;,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 2 classes due to The amyc.parsing.Tokens.EOFToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(EOFToken,[Default]), UsedName(amyc;parsing;Tokens;EOFToken;init;,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.EOFToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Raw...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Raw)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Raw)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Raw,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(s,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(amyc;utils;Raw;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(Raw,[Default]))) invalidates 1 classes due to The amyc.utils.Raw has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(s,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(amyc;utils;Raw;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(Raw,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Raw)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.ErrorToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.ErrorToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.ErrorToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(ErrorToken,[Default]), UsedName(apply,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.ErrorToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName(amyc;parsing;Tokens;ErrorToken;init;,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(ErrorToken,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 2 classes due to The amyc.parsing.Tokens.ErrorToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName(amyc;parsing;Tokens;ErrorToken;init;,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(ErrorToken,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.ErrorToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.DelimiterToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.DelimiterToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.DelimiterToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.DelimiterToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(DelimiterToken,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(amyc;parsing;Tokens;DelimiterToken;init;,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.DelimiterToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(DelimiterToken,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(amyc;parsing;Tokens;DelimiterToken;init;,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.DelimiterToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Unindented...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Unindented)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Unindented)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Unindented,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(amyc;utils;Unindented;init;,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(Unindented,[Default]))) invalidates 1 classes due to The amyc.utils.Unindented has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(print,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(content,[Default]), UsedName(==,[Default]), UsedName(<:>,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(amyc;utils;Unindented;init;,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(Unindented,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Unindented)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Env.Windows...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Env.Windows)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Env.Windows)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Env.Windows,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(Windows,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.utils.Env.Windows has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(Windows,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Env.Windows)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.UniqueCounter...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.UniqueCounter)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.UniqueCounter)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.UniqueCounter,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(UniqueCounter,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(amyc;utils;UniqueCounter;init;,[Default]), UsedName(next,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.utils.UniqueCounter has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(UniqueCounter,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(amyc;utils;UniqueCounter;init;,[Default]), UsedName(next,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.UniqueCounter)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter.Value...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter.Value)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter.Value)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter.Value,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(asInstanceOf,[Default]), UsedName(amyc;interpreter;Interpreter;Value;init;,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(asBoolean,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(Value,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter.Value has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(asInstanceOf,[Default]), UsedName(amyc;interpreter;Interpreter;Value;init;,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(asBoolean,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(Value,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter.Value)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.DelimiterKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.DelimiterKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.DelimiterKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.DelimiterKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(DelimiterKind,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName(amyc;parsing;TokenKinds;DelimiterKind;init;,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.DelimiterKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(DelimiterKind,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName(amyc;parsing;TokenKinds;DelimiterKind;init;,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.DelimiterKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.NoKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.NoKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.NoKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.NoKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(NoKind,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.NoKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(NoKind,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.NoKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.EOFKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.EOFKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.EOFKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.EOFKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(EOFKind,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.EOFKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(EOFKind,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.EOFKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Env.OS...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Env.OS)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Env.Mac by amyc.utils.Env.OS[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Env.Linux by amyc.utils.Env.OS[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Env.Windows by amyc.utils.Env.OS[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Env.Linux, amyc.utils.Env.OS, amyc.utils.Env.Mac, amyc.utils.Env.Windows)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Env.OS,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(OS,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 4 classes due to The amyc.utils.Env.OS has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(OS,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Env.Linux, amyc.utils.Env.OS, amyc.utils.Env.Mac, amyc.utils.Env.Windows)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Context...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Context)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Noop: Set(UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(Context,[Default]), UsedName(asInstanceOf,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Pipeline: Set(UsedName(Context,[Default]), UsedName(reporter,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(Context,[Default]), UsedName(isInstanceOf,[Default]), UsedName(reporter,[Default]), UsedName(files,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.DisplayTokens: Set(UsedName(Context,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Context,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(reporter,[Default]), UsedName(files,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Context,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(copy$default$5,[Default]), UsedName(help,[Default]), UsedName(printNames,[Default]), UsedName(canEqual,[Default]), UsedName(copy$default$3,[Default]), UsedName(hashCode,[Default]), UsedName(Context,[Default]), UsedName(getClass,[Default]), UsedName(amyc;utils;Context;init;,[Default]), UsedName($asInstanceOf,[Default]), UsedName(printTrees,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(copy$default$4,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(reporter,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(files,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(printTokens,[Default]), UsedName(interpret,[Default]), UsedName(copy$default$7,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(copy$default$6,[Default]))) invalidates 6 classes due to The amyc.utils.Context has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(copy$default$5,[Default]), UsedName(help,[Default]), UsedName(printNames,[Default]), UsedName(canEqual,[Default]), UsedName(copy$default$3,[Default]), UsedName(hashCode,[Default]), UsedName(Context,[Default]), UsedName(getClass,[Default]), UsedName(amyc;utils;Context;init;,[Default]), UsedName($asInstanceOf,[Default]), UsedName(printTrees,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(copy$default$4,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(reporter,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(files,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(printTokens,[Default]), UsedName(interpret,[Default]), UsedName(copy$default$7,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(copy$default$6,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Context)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.utils.Noop, amyc.utils.Pipeline, amyc.Main, amyc.parsing.DisplayTokens, amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Env...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Env)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Env)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Env,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(os,[Default]), UsedName(Windows,[Default]), UsedName(hashCode,[Default]), UsedName(Env,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(OS,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Mac,[Default]), UsedName(finalize,[Default]), UsedName(Linux,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.utils.Env has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(os,[Default]), UsedName(Windows,[Default]), UsedName(hashCode,[Default]), UsedName(Env,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(OS,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Mac,[Default]), UsedName(finalize,[Default]), UsedName(Linux,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Env)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.PrimTypeKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.PrimTypeKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.PrimTypeKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.PrimTypeKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(PrimTypeKind,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.PrimTypeKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(PrimTypeKind,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.PrimTypeKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Token...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Token)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.ErrorToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.CommentToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.PrimTypeToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.IdentifierToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.SpaceToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.StringLitToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.OperatorToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.EOFToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.KeywordToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.BoolLitToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.DelimiterToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Tokens.IntLitToken by amyc.parsing.Token[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.ErrorToken, amyc.parsing.Tokens.CommentToken, amyc.parsing.Tokens.PrimTypeToken, amyc.parsing.Tokens.IdentifierToken, amyc.parsing.Tokens.SpaceToken, amyc.parsing.Tokens.StringLitToken, amyc.parsing.Tokens.OperatorToken, amyc.parsing.Token, amyc.parsing.Tokens.EOFToken, amyc.parsing.Tokens.KeywordToken, amyc.parsing.Tokens.BoolLitToken, amyc.parsing.Tokens.DelimiterToken, amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Token,[Default, PatMatTarget]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Token,[Default, PatMatTarget]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Token,[Default, PatMatTarget]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.DisplayTokens: Set(UsedName(Token,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(Token,[Default]), UsedName(isInstanceOf,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Token,[Default, PatMatTarget]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Token,[Default, PatMatTarget]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Token,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(Token,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(position,[Default]))) invalidates 16 classes due to The amyc.parsing.Token has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(Token,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.ErrorToken, amyc.parsing.Tokens.CommentToken, amyc.parsing.Tokens.PrimTypeToken, amyc.parsing.Tokens.IdentifierToken, amyc.parsing.Tokens.SpaceToken, amyc.parsing.Tokens.StringLitToken, amyc.parsing.Tokens.OperatorToken, amyc.parsing.Token, amyc.parsing.Tokens.EOFToken, amyc.parsing.Tokens.KeywordToken, amyc.parsing.Tokens.BoolLitToken, amyc.parsing.Tokens.DelimiterToken, amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.Main, amyc.parsing.DisplayTokens, amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter.UnitValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter.UnitValue,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(UnitValue,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(asBoolean,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter.UnitValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName($init$,[Default]), UsedName(UnitValue,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(asBoolean,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.TokenKinds.KeywordKind...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.TokenKinds.KeywordKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.TokenKinds.KeywordKind)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.TokenKinds.KeywordKind,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(amyc;parsing;TokenKinds;KeywordKind;init;,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(KeywordKind,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.parsing.TokenKinds.KeywordKind has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(amyc;parsing;TokenKinds;KeywordKind;init;,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(KeywordKind,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.TokenKinds.KeywordKind)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.BoolLitToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.BoolLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.BoolLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.BoolLitToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(amyc;parsing;Tokens;BoolLitToken;init;,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]), UsedName(BoolLitToken,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.BoolLitToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(amyc;parsing;Tokens;BoolLitToken;init;,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]), UsedName(BoolLitToken,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.BoolLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.AmycFatalError...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.AmycFatalError)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.AmycFatalError)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.utils.Reporter: Set(UsedName(AmycFatalError,[Default]), UsedName(asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(msg,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(isInstanceOf,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.AmycFatalError,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(getCause,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(AmycFatalError,[Default]), UsedName(initCause,[Default]), UsedName(getClass,[Default]), UsedName(setStackTrace,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(getLocalizedMessage,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(printStackTrace,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName(getMessage,[Default]), UsedName(getStackTrace,[Default]), UsedName($isInstanceOf,[Default]), UsedName(getStackTraceDepth,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(getSuppressed,[Default]), UsedName(amyc;utils;AmycFatalError;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(msg,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(addSuppressed,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(getStackTraceElement,[Default]), UsedName(clone,[Default]), UsedName(fillInStackTrace,[Default]))) invalidates 3 classes due to The amyc.utils.AmycFatalError has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(getCause,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(AmycFatalError,[Default]), UsedName(initCause,[Default]), UsedName(getClass,[Default]), UsedName(setStackTrace,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(getLocalizedMessage,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(printStackTrace,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName(getMessage,[Default]), UsedName(getStackTrace,[Default]), UsedName($isInstanceOf,[Default]), UsedName(getStackTraceDepth,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(getSuppressed,[Default]), UsedName(amyc;utils;AmycFatalError;init;,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(msg,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(addSuppressed,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(getStackTraceElement,[Default]), UsedName(clone,[Default]), UsedName(fillInStackTrace,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.AmycFatalError)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.utils.Reporter, amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter.BooleanValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.interpreter.Interpreter.BooleanValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter.BooleanValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter.BooleanValue,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(b,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(BooleanValue,[Default]), UsedName(amyc;interpreter;Interpreter;BooleanValue;init;,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter.BooleanValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(b,[Default]), UsedName(wait,[Default]), UsedName(asInt,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(BooleanValue,[Default]), UsedName(amyc;interpreter;Interpreter;BooleanValue;init;,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(asString,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(asBoolean,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.interpreter.Interpreter.BooleanValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.IntLitToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.IntLitToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(IntLitToken,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(amyc;parsing;Tokens;IntLitToken;init;,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.IntLitToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(IntLitToken,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(amyc;parsing;Tokens;IntLitToken;init;,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(value,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.IntLitToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.SourcePositioner...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.SourcePositioner)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.SourcePositioner)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(file,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(SourcePositioner,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.SourcePositioner,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(amyc;utils;SourcePositioner;init;,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(increment,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(start,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(SourcePositioner,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]))) invalidates 2 classes due to The amyc.utils.SourcePositioner has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(amyc;utils;SourcePositioner;init;,[Default]), UsedName(file,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(increment,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(start,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(SourcePositioner,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.SourcePositioner)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.OperatorToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.OperatorToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.OperatorToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.OperatorToken,ModifiedNames(changes = UsedName(name,[Default]), UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(OperatorToken,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]), UsedName(amyc;parsing;Tokens;OperatorToken;init;,[Default]))) invalidates 1 classes due to The amyc.parsing.Tokens.OperatorToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(name,[Default]), UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(OperatorToken,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName($init$,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]), UsedName(amyc;parsing;Tokens;OperatorToken;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.OperatorToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Tokens.CommentToken...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.parsing.Tokens.CommentToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Tokens.CommentToken)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(CommentToken,[Default]), UsedName(setPos,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(apply,[Default]), UsedName(position,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Tokens.CommentToken,ModifiedNames(changes = UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(CommentToken,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName(amyc;parsing;Tokens;CommentToken;init;,[Default]), UsedName($init$,[Default]), UsedName(text,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]))) invalidates 2 classes due to The amyc.parsing.Tokens.CommentToken has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productElement,[Default]), UsedName(toString,[Default]), UsedName(canEqual,[Default]), UsedName(CommentToken,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName(hasPosition,[Default]), UsedName(setPos,[Default]), UsedName($asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(copy$default$1,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(productPrefix,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(pos_,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(copy,[Default]), UsedName(amyc;parsing;Tokens;CommentToken;init;,[Default]), UsedName($init$,[Default]), UsedName(text,[Default]), UsedName(notifyAll,[Default]), UsedName(productArity,[Default]), UsedName(compose,[Default]), UsedName(apply,[Default]), UsedName(eq,[Default]), UsedName(productIterator,[Default]), UsedName(clone,[Default]), UsedName(unapply,[Default]), UsedName(position,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.parsing.Tokens.CommentToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.utils.Pipeline...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.utils.Pipeline)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.DisplayTokens by amyc.utils.Pipeline[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.parsing.Lexer by amyc.utils.Pipeline[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.utils.Noop by amyc.utils.Pipeline[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.utils.Noop, amyc.parsing.Lexer, amyc.parsing.DisplayTokens, amyc.utils.Pipeline)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(Pipeline,[Default]), UsedName(run,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(Pipeline,[Default]), UsedName(run,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.DisplayTokens: Set(UsedName(Pipeline,[Default]), UsedName(amyc;utils;Pipeline;init;,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.parsing.Lexer: Set(UsedName(Pipeline,[Default]), UsedName(asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(isInstanceOf,[Default]), UsedName(amyc;utils;Pipeline;init;,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of amyc.Main: Set(UsedName(Pipeline,[Default]), UsedName(run,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.utils.Pipeline,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(Pipeline,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(amyc;utils;Pipeline;init;,[Default]))) invalidates 5 classes due to The amyc.utils.Pipeline has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(Pipeline,[Default]), UsedName(hashCode,[Default]), UsedName(getClass,[Default]), UsedName($asInstanceOf,[Default]), UsedName(run,[Default]), UsedName(notify,[Default]), UsedName(synchronized,[Default]), UsedName(wait,[Default]), UsedName(asInstanceOf,[Default]), UsedName(andThen,[Default]), UsedName(!=,[Default]), UsedName(##,[Default]), UsedName($isInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]), UsedName(ne,[Default]), UsedName(equals,[Default]), UsedName(notifyAll,[Default]), UsedName(eq,[Default]), UsedName(clone,[Default]), UsedName(amyc;utils;Pipeline;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(amyc.utils.Noop, amyc.parsing.Lexer, amyc.parsing.DisplayTokens, amyc.utils.Pipeline)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(amyc.Main, amyc.parsing.DisplayTokens, amyc.parsing.Lexer)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set(amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(amyc.Main)[0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll newly invalidated classes after taking into account (previously) recompiled classes:Set()[0m
